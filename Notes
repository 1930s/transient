como hacer que un closure conozca los closures de su vecino cuando en aplicative mode?
   hay que ir por filas
   runclosure
   clear children
   runcontinuation  hay varios parallel, en cada uno se añade a children
   
que pasa en flow normal?
    async inputLoop  <|> return ()      -- se añade thread
      r <- (,) <$> option1 "1" "1"  <*> option1 "2" "2"   -- se añaden 2 threads
      liftIO $ print "END"

 pero la segunda linea son hijos de return (), no de imputLoop
   por tanto la dependencia debería ser solo en event mode.
     no dependency by monadic statement in flow
       but dependency by event in closure-> continuation.

       but what happens with <|> return ()?
         create a new children list is necessary in resetEventConf
       
if update only when in event mode
it is necessary to make clear dependencies between monadic statements
  and what layer correspond to what thread.
    so
       each closure has a p[ThreadId] that start empty
         the continuation add thread to the lit
       if the execution is in flow mode
         add a new p [threadId] en resetEventCont
       

loop Wait Once IO  $ \.


----------

emit source
  con putSource
  necesita source

como extraer source de un f sin ejecutarlo.
con una signature especifica y haciendo una instancia:

instance Source (Int -> TransientIO Char) were
   ....
  no tiene suficiente definicion

hay que ejecutarlo. 
   usar un flag source= True
   mirarlo al principio de cada ejecución

Usar interpretes:
  interpret
  

simular la navegación de MFlow
 primitiva para lanzar un proceso que escucha

  deberia hacer un bucle por cada cookie, pero fork cuando es distinto
  como se 
  
cambiar rowlist para que haya menos
TVars test EVars
emit source
acabar tutorial backtracking mas ejemplos

state persistence


type EVarId= Int

newtype EVars= EVars (M.Map EVarId [(TransactId,EventF)]) deriving Typeable

newtype STMVars= STMVars [(EVarId, TransactId)]

newtype Trans= Trans TransId [EVarId]

newMVar :: a -> TransientIO (EVar a)
newMVar a = Transient $ do
   id <- genNewId
   ref <- liftIO $ newIORef a
   return . Just $ EVar id ref

readMVar (EVar id _)= do
   cont <- getCont
   STMVars map <- getSessionData `onNothing` return (STMVars M.empty)
   Trans transid varids <- getSessionData `onNothing` error "MVar not inside a atomic block"
   setSData $ STMVars $ M.insert id transid map
   setSData $ Trans transid $ id:varids
   readEvar

writeMVar = writeEVar 

atomic trans= Transient $ do
   transid <- genNewId
   setSData $ Trans transid []
   r <- trans
   EVars vars   <- getSessionData `onNothing` return (EVars M.empty)
   Trans _ ids <- getSessionData `onNothing` return (Trans 0 []) 
   setSData Evars $ map delete   evars ids
   where
   delete evars id= 
      let  Just (EVar _ conts) = M.lookup id evars <|> error(TVar not found at end of atomic block)
      M.insert id (filter ((/= id) . fst) conts)