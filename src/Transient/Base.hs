{-# LANGUAGE ScopedTypeVariables #-}
-----------------------------------------------------------------------------
--
-- Module      :  Base
-- Copyright   :
-- License     :  MIT
--
-- Maintainer  :  agocorona@gmail.com
-- Stability   :
-- Portability :
--
-- | Transient is a general purpose library for writing concurrent and parallel
-- applications. In particular, transient makes it easy to write and maintain
-- asynchronous events based (reactive) applications. It takes a novel approach
-- to the asynchronous event handling problem resulting in a very high degree
-- of composability of reactive components.
--
-- = Overview
--
-- The 'TransientIO' monad adds three key features on top of the IO monad:
--
-- * non-determinism
-- * concurrent event processing
-- * state management
--
-- == Non-determinism
--
-- In its non-concurrent form, the 'TransientIO' monad behaves exactly like a
-- <http://hackage.haskell.org/package/list-transformer list transformer monad>.
-- It is like a list whose elements are generated using IO effects. It composes
-- in the same way as a list monad. Let's see an example:
--
-- @
-- import Control.Concurrent (threadDelay)
-- import Control.Monad.IO.Class (liftIO)
-- import System.Random (randomIO)
-- import Transient.Base (keep, threads, waitEvents)
--
-- main = keep $ threads 1 $ do
--     x <- waitEvents (randomIO :: IO Int)
--     liftIO $ threadDelay 1000000
--     liftIO $ putStrLn $ show x
-- @
--
-- 'keep' runs the 'TransientIO' monad. The 'threads' primitive restricts the
-- 'TransientIO' monad to a single thread.  The 'waitEvents' primitive
-- generates values (list elements) in a loop using the 'randomIO' IO action.
-- The above code behaves like a list monad as if we are drawing elements from
-- a list generated by 'waitEvents'.  The sequence of actions following
-- 'waitEvents' is executed for each element of the list. We see a random Int
-- printed on the screen every second. As you can see this behavior is
-- identical to a list transformer monad.
--
-- == Concurrency
--
-- 'TransientIO' monad is a concurrent list transformer i.e. each element of
-- the generated list can be processed concurrently.  In the previous example
-- if we change the number of threads to 10 we can see concurrency in action:
--
-- @
-- ...
-- main = keep $ threads 10 $ do
-- ...
-- @
--
-- Now each element of the list is processed concurrently in a separate thread,
-- up to 10 threads are used. Therefore we see 10 results printed every second
-- instead of 1 in the previous version.
--
-- In the above examples the list elements are generated using a synchronous IO
-- action.  List elements can also be generated based on asynchronous events,
-- for example on a user input.  In transient, we think of each element of the
-- list as an /event/ and the list itself as a /stream of events/. The events
-- terminology is more general and sounds appropriate when the application is
-- an asynchronous events based reactive application.  In this context,
-- 'TransientIO' can be thought of as a concurrent events processing monad.
--
-- In general, the processing of an event may happen concurrently or serially
-- depending on the availability of resources. Therefore, the application must
-- be written such that the concurrent or serial processing does not make a
-- difference to the semantics of the application.
--
-- Events can be composed using the '<|>' combinator provided by the
-- 'Alternative' instance of 'TransientIO'.
--
-- == State Management
--
-- TBD
--
-- = Reactive Applications
--
-- A popular model to handle asynchronous events in imperative languages is the
-- callback model.  The control flow of the program is driven by events;
-- callbacks are event handlers that are hooked into the event generation code
-- and are invoked every time an event happens. This model makes the overall
-- control flow hard to understand because it is distributed across various
-- isolated callback handlers, known as the "callback hell".  The transient
-- programming model is opposite (dual) to the callback model. The event
-- handling code looks like a single sequential flow with event generators
-- hooked into it. The sequential state management logic makes it easy to
-- compose, understand and maintain an arbitrarily complex reactive system.
--
-- Transient provides several primitives to build event generators using IO
-- actions and also using asynchronous notification APIs (see 'react').  The
-- event handling logic of the application is sequential TransientIO code
-- written using these primitives. Non-determinism and monadic composition
-- primitives provide the expressive power whereas the concurrency and
-- parallelism features provide the efficiency and reactivity to the event
-- handling logic.
--
-- <https://hackage.haskell.org/package/axiom Axiom> is a client and server
-- side web UI and reactive application framework built using the transient
-- programming model.
--
-- = Further Reading
--
-- See the
-- <https://github.com/transient-haskell/transient/wiki/Transient-tutorial tutorial>
-- for an overview of concepts and examples.  Also see the
-- <http://github.com/agocorona/transient readme> on the github repository.
-----------------------------------------------------------------------------

module Transient.Base(
-- * The Monad
TransIO(..), TransientIO
-- * Running the monad
,keep, keep', stop, exit

-- * Asynchronous console IO
,option, input

-- * Event generation
-- $eventgen
, StreamData(..)
,parallel, async, waitEvents, sample, spawn, react

-- * State management
,setState, setData, getState, getSData,getData,delState,delData, modifyData,modifyState,try

-- * Thread management
, threads,addThreads, freeThreads, hookedThreads,oneThread, killChilds

-- * Additional operators
, (**>), (<**),(<***), (<|)

-- * exceptions

,onException, cutExceptions, continue

-- * Utilities
,genId
)

where


import    Transient.Internals

-- $eventgen
--
-- These primitives are used to create a stream of events from an IO action.
--
