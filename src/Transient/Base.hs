{-# LANGUAGE ScopedTypeVariables #-}
-----------------------------------------------------------------------------
--
-- Module      :  Base
-- Copyright   :
-- License     :  MIT
--
-- Maintainer  :  agocorona@gmail.com
-- Stability   :
-- Portability :
--
-- | Transient is a general purpose library for writing concurrent and parallel
-- applications. In particular, transient makes it easy to write and maintain
-- asynchronous events based (reactive) applications. It takes a novel approach
-- to the asynchronous event handling problem resulting in a very high degree
-- of composability of reactive components.
--
-- = Overview
--
-- The 'TransientIO' monad combines three features together to provide a
-- convenient programming model for reactive applications:
--
-- * non-determinism
-- * concurrent event processing
-- * state management
--
-- Non-deterministic concurrent event processing is the key distinguishing
-- feature of 'TransientIO', others can be found elsewhere too (non-determinism
-- alone in 'ListT' and state management in 'StateT'). There are multiple other
-- features added on top of this foundation e.g. backtracking, logging and
-- recovery to move computations across machines for distributed processing.
--
-- == Non-determinism
--
-- In its non-concurrent form, the 'TransientIO' monad behaves exactly like a
-- <http://hackage.haskell.org/package/list-transformer list transformer monad>.
-- It is like a list whose elements are generated using IO effects. It composes
-- in the same way as a list monad. Let's see an example:
--
-- @
-- import Control.Concurrent (threadDelay)
-- import Control.Monad.IO.Class (liftIO)
-- import System.Random (randomIO)
-- import Transient.Base (keep, threads, waitEvents)
--
-- main = keep $ threads 0 $ do
--     x <- waitEvents (randomIO :: IO Int)
--     liftIO $ threadDelay 1000000
--     liftIO $ putStrLn $ show x
-- @
--
-- 'keep' runs the 'TransientIO' monad. The 'threads' primitive limits the
-- number of threads to force non-concurrent operation.  The 'waitEvents'
-- primitive generates values (list elements) in a loop using the 'randomIO' IO
-- action.  The above code behaves like a list monad as if we are drawing
-- elements from a list generated by 'waitEvents'.  The sequence of actions
-- following 'waitEvents' is executed for each element of the list. We see a
-- random value printed on the screen every second. As you can see this
-- behavior is identical to a list transformer monad.
--
-- == Concurrency
--
-- 'TransientIO' monad is a concurrent list transformer i.e. each element of
-- the generated list can be processed concurrently.  In the previous example
-- if we change the number of threads to 10 we can see concurrency in action:
--
-- @
-- ...
-- main = keep $ threads 10 $ do
-- ...
-- @
--
-- Now each element of the list is processed concurrently in a separate thread,
-- up to 10 threads are used. Therefore we see 10 results printed every second
-- instead of 1 in the previous version.
--
-- In the above examples the list elements are generated using a synchronous IO
-- action.  These elements can also be generated by asynchronous events,
-- for example on a user input.  In transient, we think of each list element
-- as an event and the list itself as a stream of events. The events
-- terminology is more general and is intuitive when the application is an
-- asynchronous events based reactive application.
--
-- == Composing events
--
-- A value of type @TransientIO a@ represents an event value of type @a@ in an
-- /event stream/. An event stream may be /finite/ or /infinite/.  The absence
-- of an event, a void event or failure is denoted by a special value denoted
-- by 'empty' ('Alternative') or 'stop' monadic primitive.
--
-- As illustrated earlier, the 'Monad' instance provides a way to compose and
-- process the events in a sequential, non-deterministic and concurrent manner.
-- When a void event is encountered, the monad stops processing any further
-- computations, no events means nothing to be done.  The following example
-- does not generate any output after "stop here":
--
-- @
-- main = keep $ threads 0 $ do
--     x <- waitEvents (randomIO :: IO Int)
--     liftIO $ threadDelay 1000000
--     liftIO $ putStrLn $ "stop here"
--     stop
--     liftIO $ putStrLn $ show x
-- @
--
-- Asynchronous (concurrent) event primitives (e.g. 'waitEvents') return a void
-- event, which means the current thread stops processing. However, processing
-- resumes from the same point onwards in a separate event thread when the
-- event occurs asynchronously. In the following example you can see that the
-- thread id changes after the 'waitEvents' call:
--
-- @
-- main = keep $ threads 1 $ do
--     mainThread <- liftIO myThreadId
--     liftIO $ putStrLn $ "Main thread: " ++ show mainThread
--     x <- waitEvents (randomIO :: IO Int)
--
--     liftIO $ threadDelay 1000000
--     evThread <- liftIO myThreadId
--     liftIO $ putStrLn $ "Event thread: " ++ show evThread
-- @
--
-- Note that if we use @threads 0@ instead then the event thread and the main
-- thread are the same because 'waitEvents' falls back to synchronous
-- non-concurrent mode, and therefore returns a non void event.
--
-- In an 'Alternative' composition, when a computation results in 'empty' the
-- next alternative is tried. Asynchronous (concurrent) event primitives return
-- 'empty' allowing multiple of those to be combined to run concurrently using
-- the '<|>' combinator. The following example combines two single concurrent
-- events generated by 'async':
--
-- @
-- main = keep $ do
--     x <- event 1 \<|\> event 2
--     liftIO $ putStrLn $ show x
--     where event n = async (return n :: IO Int)
-- @
--
-- Note that availability of threads can impact the behavior of an application.
-- An infinite event stream generator (e.g. 'waitEvents' or 'sample') running
-- synchronously due to lack of threads can block all other computations in an
-- 'Alternative' composition.  The following example does not fire the 'async'
-- event unless we increase the number of threads to make 'waitEvents'
-- asynchronous:
--
-- @
-- main = keep $ threads 0 $ do
--     x <- waitEvents (randomIO :: IO Int) \<|\> async (return 0 :: IO Int)
--     liftIO $ threadDelay 1000000
--     liftIO $ putStrLn $ show x
-- @
--
-- == State Management
--
-- The 'TransientIO' monad  provides 'setData' and 'getSData' routines to store
-- and retrieve user data.  'TransientIO' is also a 'StateT' monad internally,
-- and therefore the semantics of storing and retrieving state are exactly the
-- same as a 'State' monad.
--
-- = Reactive Applications
--
-- A popular model to handle asynchronous events in imperative languages is the
-- callback model.  The control flow of the program is driven by events;
-- callbacks are event handlers that are hooked into the event generation code
-- and are invoked every time an event happens. This model makes the overall
-- control flow hard to understand because it is distributed across various
-- isolated callback handlers, known as the "callback hell".  The transient
-- programming model is opposite (dual) to the callback model. The event
-- handling code looks like a single sequential flow with event generators
-- hooked into it. The sequential state management logic makes it easy to
-- compose, understand and maintain an arbitrarily complex reactive system.
--
-- Transient provides several primitives to build event generators using IO
-- actions and also using asynchronous notification APIs (see 'react').  The
-- event handling logic of the application is sequential TransientIO code
-- written using these primitives. Non-determinism and monadic composition
-- primitives provide the expressive power whereas the concurrency and
-- parallelism features provide the efficiency and reactivity to the event
-- handling logic.
--
-- <https://hackage.haskell.org/package/axiom Axiom> is a client and server
-- side web UI and reactive application framework built using the transient
-- programming model.
--
-- = Further Reading
--
-- See the
-- <https://github.com/transient-haskell/transient/wiki/Transient-tutorial tutorial>
-- for an overview of concepts and examples.  Also see the
-- <http://github.com/agocorona/transient readme> on the github repository.
-----------------------------------------------------------------------------

module Transient.Base(
-- * The Monad
TransIO(..), TransientIO
-- * Running the monad
,keep, keep', stop, exit

-- * Asynchronous console IO
,option, input

-- * Event generation
-- $eventgen
, StreamData(..)
,parallel, async, waitEvents, sample, spawn, react

-- * State management
,setData, getSData, getData, delData, modifyData, try, setState, getState, delState, modifyState

-- * Thread management
, threads,addThreads, freeThreads, hookedThreads,oneThread, killChilds

-- * Additional operators
, (**>), (<**),(<***), (<|)

-- * exceptions

,onException, cutExceptions, continue

-- * Utilities
,genId
)

where


import    Transient.Internals

-- $eventgen
--
-- These primitives are used to create a stream of events from an IO action.
--
